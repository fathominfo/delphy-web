// automatically generated by the FlatBuffers compiler, do not modify

import * as flatbuffers from 'flatbuffers';

export class Params {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):Params {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsParams(bb:flatbuffers.ByteBuffer, obj?:Params):Params {
  return (obj || new Params()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsParams(bb:flatbuffers.ByteBuffer, obj?:Params):Params {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Params()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

numIters():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt64(this.bb_pos + offset) : BigInt('0');
}

numParts():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

mu():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

alpha():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

nu(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readFloat64(this.bb!.__vector(this.bb_pos + offset) + index * 8) : 0;
}

nuLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

nuArray():Float64Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? new Float64Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

hkyKappa():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

hkyPiA():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

hkyPiC():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

hkyPiG():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

hkyPiT():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

popN0():number {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

popG():number {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

onlyDisplacingInnerNodes():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

topologyMovesEnabled():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

repartitioningEnabled():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

alphaMoveEnabled():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

lnPosterior():number {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

lnPrior():number {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

lnCoalescentPrior():number {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

lnLikelihood():number {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

totalBranchLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

numLocalMovesPerGlobalMove():bigint {
  const offset = this.bb!.__offset(this.bb_pos, 46);
  return offset ? this.bb!.readInt64(this.bb_pos + offset) : BigInt('-1');
}

static startParams(builder:flatbuffers.Builder) {
  builder.startObject(22);
}

static addNumIters(builder:flatbuffers.Builder, numIters:bigint) {
  builder.addFieldInt64(0, numIters, BigInt('0'));
}

static addNumParts(builder:flatbuffers.Builder, numParts:number) {
  builder.addFieldInt32(1, numParts, 0);
}

static addMu(builder:flatbuffers.Builder, mu:number) {
  builder.addFieldFloat64(2, mu, 0.0);
}

static addAlpha(builder:flatbuffers.Builder, alpha:number) {
  builder.addFieldFloat64(3, alpha, 0.0);
}

static addNu(builder:flatbuffers.Builder, nuOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, nuOffset, 0);
}

static createNuVector(builder:flatbuffers.Builder, data:number[]|Float64Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createNuVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createNuVector(builder:flatbuffers.Builder, data:number[]|Float64Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(8, data.length, 8);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addFloat64(data[i]!);
  }
  return builder.endVector();
}

static startNuVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(8, numElems, 8);
}

static addHkyKappa(builder:flatbuffers.Builder, hkyKappa:number) {
  builder.addFieldFloat64(5, hkyKappa, 0.0);
}

static addHkyPiA(builder:flatbuffers.Builder, hkyPiA:number) {
  builder.addFieldFloat64(6, hkyPiA, 0.0);
}

static addHkyPiC(builder:flatbuffers.Builder, hkyPiC:number) {
  builder.addFieldFloat64(7, hkyPiC, 0.0);
}

static addHkyPiG(builder:flatbuffers.Builder, hkyPiG:number) {
  builder.addFieldFloat64(8, hkyPiG, 0.0);
}

static addHkyPiT(builder:flatbuffers.Builder, hkyPiT:number) {
  builder.addFieldFloat64(9, hkyPiT, 0.0);
}

static addPopN0(builder:flatbuffers.Builder, popN0:number) {
  builder.addFieldFloat64(10, popN0, 0.0);
}

static addPopG(builder:flatbuffers.Builder, popG:number) {
  builder.addFieldFloat64(11, popG, 0.0);
}

static addOnlyDisplacingInnerNodes(builder:flatbuffers.Builder, onlyDisplacingInnerNodes:boolean) {
  builder.addFieldInt8(12, +onlyDisplacingInnerNodes, +false);
}

static addTopologyMovesEnabled(builder:flatbuffers.Builder, topologyMovesEnabled:boolean) {
  builder.addFieldInt8(13, +topologyMovesEnabled, +false);
}

static addRepartitioningEnabled(builder:flatbuffers.Builder, repartitioningEnabled:boolean) {
  builder.addFieldInt8(14, +repartitioningEnabled, +false);
}

static addAlphaMoveEnabled(builder:flatbuffers.Builder, alphaMoveEnabled:boolean) {
  builder.addFieldInt8(15, +alphaMoveEnabled, +false);
}

static addLnPosterior(builder:flatbuffers.Builder, lnPosterior:number) {
  builder.addFieldFloat64(16, lnPosterior, 0.0);
}

static addLnPrior(builder:flatbuffers.Builder, lnPrior:number) {
  builder.addFieldFloat64(17, lnPrior, 0.0);
}

static addLnCoalescentPrior(builder:flatbuffers.Builder, lnCoalescentPrior:number) {
  builder.addFieldFloat64(18, lnCoalescentPrior, 0.0);
}

static addLnLikelihood(builder:flatbuffers.Builder, lnLikelihood:number) {
  builder.addFieldFloat64(19, lnLikelihood, 0.0);
}

static addTotalBranchLength(builder:flatbuffers.Builder, totalBranchLength:number) {
  builder.addFieldFloat64(20, totalBranchLength, 0.0);
}

static addNumLocalMovesPerGlobalMove(builder:flatbuffers.Builder, numLocalMovesPerGlobalMove:bigint) {
  builder.addFieldInt64(21, numLocalMovesPerGlobalMove, BigInt('-1'));
}

static endParams(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createParams(builder:flatbuffers.Builder, numIters:bigint, numParts:number, mu:number, alpha:number, nuOffset:flatbuffers.Offset, hkyKappa:number, hkyPiA:number, hkyPiC:number, hkyPiG:number, hkyPiT:number, popN0:number, popG:number, onlyDisplacingInnerNodes:boolean, topologyMovesEnabled:boolean, repartitioningEnabled:boolean, alphaMoveEnabled:boolean, lnPosterior:number, lnPrior:number, lnCoalescentPrior:number, lnLikelihood:number, totalBranchLength:number, numLocalMovesPerGlobalMove:bigint):flatbuffers.Offset {
  Params.startParams(builder);
  Params.addNumIters(builder, numIters);
  Params.addNumParts(builder, numParts);
  Params.addMu(builder, mu);
  Params.addAlpha(builder, alpha);
  Params.addNu(builder, nuOffset);
  Params.addHkyKappa(builder, hkyKappa);
  Params.addHkyPiA(builder, hkyPiA);
  Params.addHkyPiC(builder, hkyPiC);
  Params.addHkyPiG(builder, hkyPiG);
  Params.addHkyPiT(builder, hkyPiT);
  Params.addPopN0(builder, popN0);
  Params.addPopG(builder, popG);
  Params.addOnlyDisplacingInnerNodes(builder, onlyDisplacingInnerNodes);
  Params.addTopologyMovesEnabled(builder, topologyMovesEnabled);
  Params.addRepartitioningEnabled(builder, repartitioningEnabled);
  Params.addAlphaMoveEnabled(builder, alphaMoveEnabled);
  Params.addLnPosterior(builder, lnPosterior);
  Params.addLnPrior(builder, lnPrior);
  Params.addLnCoalescentPrior(builder, lnCoalescentPrior);
  Params.addLnLikelihood(builder, lnLikelihood);
  Params.addTotalBranchLength(builder, totalBranchLength);
  Params.addNumLocalMovesPerGlobalMove(builder, numLocalMovesPerGlobalMove);
  return Params.endParams(builder);
}
}
